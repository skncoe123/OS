#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char data[20][2]; // 2nd column stores distance or time
    int end;
} queue;

void enqueue(queue *q, char data, int position);
char dequeue(queue *q, int position);

void fifo(char string[], int frameSize, int count);
void optimal(char string[], int frameSize, int count);
void lru(char string[], int frameSize, int count);

int main() {
    int frameSize, count, ch;
    char string[50];

    printf("Enter the string: ");
    count = 0;
    do {
        scanf("%c", &string[count]);
        count++;
    } while (string[count - 1] != '\n');
    string[count - 1] = '\0'; // Null-terminate the string
    count--; // This is the number of data available
    printf("\nEnter the size of the frame: ");
    scanf("%d", &frameSize);
    
    do {
        printf("\nMENU\n====\n1.FIFO\n2.Least Recently Used (LRU)\n3.Optimal\n4.Exit\n\nYour Choice: ");
        scanf("%d", &ch);
        switch (ch) {
            case 1: fifo(string, frameSize, count); break;
            case 2: lru(string, frameSize, count); break;
            case 3: optimal(string, frameSize, count); break;
            case 4: exit(0); break;
            default: printf("\nInvalid choice! Please try again!"); continue;
        }
    } while (ch != 4);

    return 0;
}

void enqueue(queue *q, char data, int position) {
    q->data[position][0] = data;
}

char dequeue(queue *q, int position) {
    char value;
    value = q->data[position][0];
    return value;
}

void fifo(char string[], int frameSize, int count) {
    int cnt, cnt2, flag, faults = 0;
    queue q;
    int firstin = 0;
    q.end = 0;

    printf("\nData Requested\tFrame contents\t    Page Fault\n==============================================");
    for (cnt = 0; cnt < count; cnt++) {
        printf("\n\n\t%c", string[cnt]);
        flag = 0;

        for (cnt2 = 0; cnt2 < q.end; cnt2++) {
            if (string[cnt] == q.data[cnt2][0]) {
                flag = 1;
                break;
            }
        }
        if (flag == 0) {
            faults++;
            if (q.end < frameSize) {
                // Frame has empty slots
                enqueue(&q, string[cnt], q.end);
                q.end++;
            } else {
                // Replace the first page
                dequeue(&q, firstin);
                enqueue(&q, string[cnt], firstin);
                firstin = (firstin + 1) % frameSize; // Update the firstin index
            }
            printf("\t  ");
            for (cnt2 = 0; cnt2 < q.end; cnt2++) {
                printf("%c   ", q.data[cnt2][0]);
            }
            printf("\t\tY");
        } else {
            printf("\t  ");
            for (cnt2 = 0; cnt2 < q.end; cnt2++) {
                printf("%c   ", q.data[cnt2][0]);
            }
            printf("\t\tN");
        }
    }
    printf("\n\n==============================================\n");
    printf("\nTotal no. of Page Faults: %d\n\n", faults);
}

void optimal(char string[], int frameSize, int count) {
    int cnt, cnt2, selector, flag, max, faults = 0;
    int distance[20];
    queue q;
    q.end = 0;

    printf("\nData Requested\tFrame contents\t    Page Fault\n==============================================");
    for (cnt = 0; cnt < count; cnt++) {
        printf("\n\n\t%c", string[cnt]);
        flag = 0;

        for (cnt2 = 0; cnt2 < q.end; cnt2++) {
            // Check for existing data in pages
            if (string[cnt] == q.data[cnt2][0]) {
                flag = 1;
                break;
            }
        }
        if (flag == 0) {
            faults++;
            if (q.end < frameSize) {
                // Frame has empty slots
                enqueue(&q, string[cnt], q.end);
                q.end++;
            } else {
                for (cnt2 = 0; cnt2 < q.end; cnt2++) {
                    // Reset reference distances
                    distance[cnt2] = -1;
                }
                for (selector = 0; selector < q.end; selector++) {
                    // Calculate distance of next reference from current position
                    for (cnt2 = cnt + 1; cnt2 < count; cnt2++) {
                        if (string[cnt2] == q.data[selector][0]) {
                            distance[selector] = cnt2; // Update the distance
                            break;
                        }
                    }
                }

                // Select farthest referenced page for replacement
                max = -1;
                for (cnt2 = 0; cnt2 < q.end; cnt2++) {
                    if (distance[cnt2] == -1) {
                        selector = cnt2; // Page that won't be used again
                        break;
                    }
                    if (distance[cnt2] > max) {
                        max = distance[cnt2];
                        selector = cnt2;
                    }
                }
                dequeue(&q, selector);
                enqueue(&q, string[cnt], selector);
            }
            printf("\t  ");
            for (cnt2 = 0; cnt2 < q.end; cnt2++) {
                printf("%c   ", q.data[cnt2][0]);
            }
            printf("\t\tY");
        } else {
            // Data exists in page frame
            printf("\t  ");
            for (cnt2 = 0; cnt2 < q.end; cnt2++) {
                printf("%c   ", q.data[cnt2][0]);
            }
            printf("\t\tN");
        }
    }
    printf("\n\n==============================================\n");
    printf("\nTotal no. of Page Faults: %d\n\n", faults);
}

void lru(char string[], int frameSize, int count) {
    int cnt, cnt2, selector, flag, min, faults = 0;
    queue q;
    q.end = 0;

    printf("\nData Requested\tFrame contents\t    Page Fault\n==============================================");
    for (cnt = 0; cnt < count; cnt++) {
        printf("\n\n\t%c", string[cnt]);
        flag = 0;

        for (cnt2 = 0; cnt2 < q.end; cnt2++) {
            // Check for existing data in pages
            if (string[cnt] == q.data[cnt2][0]) {
                flag = 1;
                break;
            }
        }
        if (flag == 0) {
            faults++;
            if (q.end < frameSize) {
                // Frame has empty slots
                enqueue(&q, string[cnt], q.end);
                q.end++;
            } else {
                min = 99;
                // Select the least recently used page for replacement
                for (cnt2 = 0; cnt2 < q.end; cnt2++) {
                    if (q.data[cnt2][1] < min) {
                        min = q.data[cnt2][1];
                        selector = cnt2;
                    }
                }
                dequeue(&q, selector);
                enqueue(&q, string[cnt], selector);
            }
            printf("\t  ");
            for (cnt2 = 0; cnt2 < q.end; cnt2++) {
                printf("%c   ", q.data[cnt2][0]);
            }
            printf("\t\tY");
        } else {
            // Data exists in page frame
            printf("\t  ");
            for (cnt2 = 0; cnt2 < q.end; cnt2++) {
                printf("%c   ", q.data[cnt2][0]);
            }
            printf("\t\tN");
        }
    }
    printf("\n\n==============================================\n");
    printf("\nTotal no. of Page Faults: %d\n\n", faults);
}

